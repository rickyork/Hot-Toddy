<?php
   class hDatabase { const autoIncrement = "int(11) NOT NULL auto_increment"; const id = "int(11) NOT NULL default '0'"; const name = "varchar(255) NOT NULL default ''"; const timestamp = "TIMESTAMP DEFAULT '0000-00-00 00:00:00'"; const longText = "LONGTEXT NOT NULL"; const mediumText = "MEDIUMTEXT NOT NULL"; const text = "TEXT NOT NULL"; const time = "int(32) NOT NULL default '0'"; const is = "tinyint(1) NOT NULL default '0'"; const latitudeLongitude = "float(32,12) NOT NULL default '0'"; const floatTemplate = "float({size},{precision}) NOT NULL default '{default}'"; const intTemplate = "int({size}) NOT NULL default '{default}'"; const tinyIntTemplate = "tinyint({size}) NOT NULL default '{default}'"; const varCharTemplate = "varchar({size}) NOT NULL default '{default}'"; const charTemplate = "char({size}) NOT NULL default '{default}'"; private $table; private $tables = array(); public $columns; private $firstColumns; private $primaryKeys; private $primaryKeyValue; private $primaryIncrementKeys; private $useLimit = false; private $overloadExceptions = array(); private $resultCount = 0; private $hFileIcon; private $defaultResult = 0; private $prependResult = array(); private $resultIndex = nil; public $hDB;  private $hFramework; private $lastQuery = nil; private $methods = array( 'password', 'find_in_set' ); public static function floatTemplate($size = 11, $precision = 2, $default = 0) {                       return str_replace( array('{size}', '{precision}', '{default}'), array($size, $precision, $default), self::floatTemplate ); } public static function intTemplate($size = 11, $default = 0) {                      return str_replace( array('{size}', '{default}'), array($size, $default), self::intTemplate ); } public static function tinyIntTemplate($size = 1, $default = 0) {                      return str_replace( array('{size}', '{default}'), array($size, $default), self::tinyIntTemplate ); } public static function varCharTemplate($size = 25, $default = '') {                       return str_replace( array('{size}', '{default}'), array($size, $default), self::varCharTemplate ); } public static function charTemplate($size = 25, $default = '') {                       return str_replace( array('{size}', '{default}'), array($size, $default), self::charTemplate ); } public function __construct() {   $this->getTables(); } public function __call($method, $arguments) {                                                              if (substr($method, 0, 6) == 'select') { switch ($method) { case 'selectColumn': $select = 'getColumn'; break; case 'selectExists': $select = 'resultsExist'; break; case 'selectAssociative': $select = 'getAssociativeResults'; break; case 'selectResults': $select = 'getResults'; break; case 'selectQuery': $select = 'query'; break; case 'selectCount': $select = 'getResultCount'; break; case 'selectColumnsAsKeyValue': $select = 'getAssociativeArray'; break; case 'selectForTemplate': $select = 'getResultsForTemplate'; break; default: { $GLOBALS['hFramework']->warning( "Unimplemented database method '{$method}'.", __FILE__, __LINE__ ); } } return $this->select( isset($arguments[0])? $arguments[0] : '*',  isset($arguments[1])? $arguments[1] : nil,  isset($arguments[2])? $arguments[2] : nil,  isset($arguments[3])? $arguments[3] : 'AND',  isset($arguments[4])? $arguments[4] : nil,  isset($arguments[5])? $arguments[5] : nil,  $select ); } if ($this->tableExists($method)) { return $this->select( isset($arguments[0])? $arguments[0] : '*',  $method,  isset($arguments[1])? $arguments[1] : nil,  isset($arguments[2])? $arguments[2] : 'AND',  isset($arguments[3])? $arguments[3] : nil,  isset($arguments[4])? $arguments[4] : nil,  'selectResults' ); } if (empty($this->hDB)) { $driver = 'hDatabaseDriver_'.strToUpper( $GLOBALS['hFramework']->hDatabaseDriver('MYSQLI') ); $this->hDB = new $driver($GLOBALS['hFramework']); } if (method_exists($this->hDB, $method)) { return call_user_func_array( array( &$this->hDB, $method ), $arguments ); }   if (method_exists($GLOBALS['hFramework'], $method)) { return call_user_func_array( array( $GLOBALS['hFramework'], $method ), $arguments ); } return $GLOBALS['hFramework']->fuseObjects( $method, $arguments ); } public function __set($key, $value) { $GLOBALS['hFramework']->__set($key, $value); } public function __get($key) { return $GLOBALS['hFramework']->__get($key); } public function &setDefaultResult($defaultResult) {         $this->defaultResult = $defaultResult; return $this; } public function &setPrependResult($value) {         $this->prependResult = array($value); return $this; } public function &setResultIndex($index) {         $this->resultIndex = $index; return $this; } public function &setWhere($where) {        $this->where = $where; return $this; } private function singleRecordOperation($key, $value = nil, $update = false) {                if ($this->hasPrimaryKey()) { if (!empty($this->primaryKeyValue)) { if (empty($update)) { $this->updateSingle($key, $value); } else { return $this->selectSingle($key); } } else { $GLOBALS['hFramework']->warning( "There is no primary key value set, unable to select/update a ". "single record in column '{$key}' in table '{$this->table}'.", __FILE__, __LINE__ ); } } else { $GLOBALS['hFramework']->warning( "The table '{$this->table}' does not have a primary key defined.", __FILE__, __LINE__ ); } } public function columnExists($column, $table = nil) {          if (preg_match('/^[A-Z|a-z|0-9|\s|\-|\_|\.]+$/', $column) >= 1 && preg_match('/^[A-Z|a-z|0-9|\s|\-|\_|\.]+$/', $table) >= 1) { $this->whichTable($table); if (!empty($table)) { $this->getColumns($table); if (!empty($column) && isset($this->columns[$table]) && is_array($this->columns[$table])) { foreach ($this->columns[$table] as $columnInTable => $data) { if (strToLower($columnInTable) == strToLower($column)) { return true; } } return false; } else { $GLOBALS['hFramework']->warning( "Unable to determine if the column exists in table '{$table}'.", __FILE__, __LINE__ ); return false; } } } return false; } public function columnsExist(Array $columns, $table = nil) {          $this->whichTable($table); if (!empty($table)) { foreach ($columns as $column) { if (!$this->columnExists($column, $table)) { return false; } } return true; } return false; } public function getXML() { } public function select($columns = '*', $tables = nil, $where = nil, $logicalOperator = 'AND', $order = nil, $limit = 0, $method = 'getResults') {                                                                                         if (!is_array($tables) && !is_array($where)) { $this->whichWhere($where, $tables) ->setTable($tables) ->whichTable($tables); } $formattedColumns = array(); $distinct = false; $count = false; if (is_array($columns)) { foreach ($columns as $i => $column) { if ($column == 'SQL_CALC_FOUND_ROWS' || $column == 'COUNT') { $count = true; continue; } if ($column == 'DISTINCT') { $distinct = true; continue; } if ($column == 'hFilePath') { array_push( $formattedColumns, "REPLACE(". "CONCAT(". "(". "SELECT `hDirectoryPath` ". "FROM `hDirectories` ". "WHERE `hDirectoryId` = `hFiles`.`hDirectoryId`". "), ". "'/', ". "`hFiles`.`hFileName`". "), ". "'//', ". "'/'". ") AS `hFilePath`" ); continue; } if ($column == '@hFilePath') { $column = 'hFilePath'; } if (is_array($column)) { foreach ($column as $n) { array_push( $formattedColumns, "`{$i}`.`{$n}`" ); } } else { if (!is_numeric($i)) { array_push( $formattedColumns, "`{$i}`.`{$column}`" ); } else { array_push( $formattedColumns, "`{$column}`" ); } } } } else { array_push( $formattedColumns, $columns != '*' ? "`{$columns}`" : '*' ); } if (is_array($tables)) { foreach ($tables as $i => $table) { $tables[$i] = "`{$table}`"; } } else { $tables = "`{$tables}`"; } if (is_array($where)) { $where = $this->where($where, $logicalOperator, nil); } $sql = "SELECT ". ($count? ' SQL_CALC_FOUND_ROWS ' : ''). ($distinct? 'DISTINCT ' : ''). implode(', ', $formattedColumns)."
               FROM ".(is_array($tables)? implode(', ', $tables) : $tables); if (!empty($where)) { $sql .= " WHERE ".$where; } if (!empty($order)) { $sql .= " ORDER BY "; $direction = 'ASC'; $random = false; if (is_array($order)) { $sortByColumns = array(); foreach ($order as $i => $column) { if ($column == 'ASC' || $column == 'DESC') { $direction = $column; continue; } array_push( $sortByColumns, (is_numeric($i)? '' : "`{$i}`.")."`{$column}`" ); } $sql .= implode(', ', $sortByColumns); } else if ($order == 'RAND' || $order == 'random') { $sql .= " RAND()"; $random = true; } else if (strstr($order, '.')) { $bits = explode('.', $order); $sql .= "`{$bits[0]}`.`{$bits[1]}`"; } else { $sql .= "`{$order}`"; } if (!$random) { $sql .= ' '.$direction; } } if (!empty($limit)) { $sql .= ' LIMIT '.$limit; } $defaultResult = $this->defaultResult; $this->defaultResult = 0; $prependResult = $this->prependResult; $this->prependResult = array(); $resultIndex = $this->resultIndex; $this->resultIndex = nil; $this->lastQuery = $sql; switch ($method) { case 'resultsExist': case 'getAssociativeResults': case 'getResultCount': { return $this->hDB->$method($sql, true); } case 'getAssociativeArray': { return $this->getAssociativeArray( $sql, isset($prependResult[0]), isset($prependResult[0]) ? $prependResult[0] : nil ); } case 'getColumn': { return $this->hDB->getColumn($sql, $defaultResult); } case 'getResults': { return $this->getResults($sql, $resultIndex); } default: { return $this->$method($sql); } } } public function getLastQuery() {         return $this->lastQuery; } public function selectSingle($column, $value = nil, $table = nil) {              $this->whichTable($table)->whichValue($value); $sql = "SELECT `{$column}`
               FROM `{$this->hDatabaseInitial}`.`{$table}`
              WHERE `{$this->primaryKeys[$table]}` = '{$value}'"; $this->lastQuery = $sql; return $this->getResult($sql); } public function update(array $columns, $where = nil, $table = nil, $logicalOperator = 'AND', $key = nil, $quoteColumns = true) {       $this->whichTable($table) ->setTable($table) ->whichWhere($where, $table); if (is_array($where)) { $where = $this->where($where, $logicalOperator, $key); } if (!empty($where)) { $columnNames = $this->getColumnsForOperation($columns, $table); $this->expandNumericColumns($columns, $columnNames); $set = array(); foreach ($columns as $column => $value) { if (isset($this->primaryKeys[$table]) && $this->primaryKeys[$table] != $column || !isset($this->primaryKeys[$table])) { if ($quoteColumns) { $set[] = $this->getColumnValueSQL(nil, $column, '=', $value); } else { $set[] = "`{$column}` = {$value}"; } } } $sql = "UPDATE `{$this->hDatabaseInitial}`.`{$table}`
                  SET ".implode(',', $set)."
                WHERE {$where}". ($this->useLimit? ' LIMIT 1' : ''); $this->lastQuery = $sql; return $this->getAffectedCount($sql); } return 0; } public function where(array $columns, $logicalOperator = 'AND', $key = nil) {        $where = array(); $statements = array(); foreach ($columns as $column => $value) { if (is_numeric($column)) { $column = $value; $value = $key; } if (strstr($column, '.')) { list($table, $column) = explode('.', $column); } if (!is_array($value)) { $columnResult = $this->checkValueForColumns($value); if ($columnResult !== false) { list($table2, $column2) = $columnResult; } if (strstr($column, ' ')) { list($column, $operator) = explode(' ', $column); } else { $operator = '='; } } else { if (is_array($value[0])) { $operators = array(); $values = array(); foreach ($value as $c => $colValue) { array_push($operators, $colValue[0]); array_push($values, $colValue[1]); } } else { $operator = $value[0]; $value = $value[1]; } } if (!isset($operators) && !isset($values)) { array_push( $where, $this->getColumnValueSQL( isset($table)? $table : nil, $column, $operator, $value, isset($table2)? $table2 : nil, isset($column2)? $column2 : nil ) ); } else { foreach ($operators as $v => $operator) { $columnResult = $this->checkValueForColumns($values[$v]); if ($columnResult !== false) { list($table2, $column2) = $columnResult; } array_push( $where, $this->getColumnValueSQL( isset($table)? $table : nil, $column, $operator, $values[$v], isset($table2)? $table2 : nil, isset($column2)? $column2 : nil ) ); unset($table2, $column2); } unset($operators, $values); } unset($table2, $column2); } return implode(' '.$logicalOperator.' ', $where); } private function checkValueForColumns($value) {                   if (strStr($value, '.')) {   if (preg_match('/^[A-Z|a-z|0-9|\s|\-|\_|\.]+$/', $value) > 0) {  list($table, $column) = explode('.', $value);    if ($this->tableExists($table)) {    return $this->columnExists($column, $table)? array($table, $column) : false; } else { return false; } } } return false; } private function getColumnValueSQL($table, $column, $operator, $value, $table2 = nil, $column2 = nil) { $sql = ''; if (substr($value, 0, 12) == 'FIND_IN_SET(') {  $value = str_replace(')', ", `{$column}`)"); $operator = false; } if ($operator != false) { if (!empty($table)) { $sql .= "`{$table}`."; } $sql .= "`{$column}` {$operator} "; } if (!empty($table2) && !empty($column2)) { $sql .= "`{$table2}`.`{$column2}`"; } else { if (!is_numeric($value) && $value !== 0) {      $isMethod = false; foreach ($this->methods as $method) { if (substr($value, 0, strlen($method.'(') ) == $method.'(') { $isMethod = true; break; } } if (subStr($value, 0, 1) == "'" && subStr($value, -1) == "'" || $isMethod || subStr($value, 0, 1) == "`" && subStr($value, -1) == "`") { $sql .= $value; } else if (strStr($value, '+') || strStr($value, '-'))  { switch (true) { case strStr($value, '+'): { $operator = '+'; break; } case strStr($value, '-'): { $operator = '-'; break; } } list($first, $second) = explode($operator, $value); $first = trim($first); $second = trim($second); $sql .= ($first == $column)? "`{$first}` {$operator} {$second}" : "'{$value}'"; } else { $sql .= "'{$value}'"; } } else { if (subStr($value, 0, 1) == '0') { $sql .= "'{$value}'"; } else { $sql .= empty($value)? '0' : $value; } } } return $sql; } public function truncate($table) {                   return $this->delete($table); } public function delete($tables, $columns = nil, $key = nil, $logicalOperator = 'AND') {                                                                                                                                                                  $this->lastQuery = nil; if (empty($columns) && empty($key)) { if (!is_array($tables)) { if (!empty($tables) && $this->tableExists($tables)) { return $this->getAffectedCount("TRUNCATE `{$tables}`"); } else { $GLOBALS['hFramework']->warning( "Unable to truncate '{$tables}' because it does not exist.", __FILE__, __LINE__ ); return 0; } } else { $counter = 0; foreach ($tables as $table) { if (!empty($table) && $this->tableExists($table)) { $counter += $this->getAffectedCount("TRUNCATE `{$table}`"); } else { $GLOBALS['hFramework']->warning( "Unable to truncate '{$table}' because it does not exist.", __FILE__, __LINE__ ); } } } return $counter; } if (!empty($tables)) { if (!empty($columns)) { if (is_array($tables)) { $counter = 0; foreach ($tables as $column => $table) { if ($this->tableExists($table)) { if (is_numeric($column)) { if (is_array($columns)) { $counter += $this->deleteSingle( $this->where( $columns, $logicalOperator ), $table, $key ); } else { $counter += $this->deleteSingle( "`{$columns}` = '{$key}'", $table ); } } else { $counter += $this->deleteSingle( "`{$columns}` = '{$key}'", $table ); } } else { $GLOBALS['hFramework']->warning( "Table '{$table}' does not exist.", __FILE__, __LINE__ ); } } return $counter; } else { if ($this->tableExists($tables)) { if (is_array($columns)) { return $this->deleteSingle( $this->where( $columns, $logicalOperator ), $tables ); } else { return $this->deleteSingle( "`{$columns}` = '{$key}'", $tables ); } } else { $GLOBALS['hFramework']->warning( "Table '{$tables}' does not exist.", __FILE__, __LINE__ ); } } } else { $GLOBALS['hFramework']->warning( '2nd Argument must be an array of columns, a single column, '. 'or a single key value.', __FILE__, __LINE__ ); } } else { $GLOBALS['hFramework']->warning( '1st Argument must be an array of tables and columns, an array '. 'of tables or a single table.', __FILE__, __LINE__ ); } return 0; } public function deleteSingle($where = nil, $table = nil) {        $this->whichTable($table) ->whichWhere($where, $table); if (!empty($where) && !empty($table)) { $sql = "DELETE
                   FROM `{$this->hDatabaseInitial}`.`{$table}`
                  WHERE {$where}". ($this->useLimit? ' LIMIT 1' : ''); $this->lastQuery = $sql; return $this->getAffectedCount($sql); } return 0; } public function updateSingle($column, $value, $primaryKeyValue = nil, $table = nil) {                             $this->whichValue($primaryKeyValue)->whichTable($table); if (empty($table) || empty($primaryKeyValue)) { $GLOBALS['hFramework']->warning( "Call to updateSingle() failed, either the \$table, '{$table}' was ". "empty or the \$primaryKeyValue '{$primaryKeyValue}' was empty.", __FILE__, __LINE__ ); return false; } if (!is_numeric($primaryKeyValue)) { $primaryKeyValue = "'{$primaryKeyValue}'"; } $sql = "UPDATE `{$this->hDatabaseInitial}`.`{$table}`
                SET `{$column}` = '{$value}'
              WHERE `{$this->primaryKeys[$table]}` = {$primaryKeyValue}"; $this->lastQuery = $sql; return $this->getAffectedCount($sql); } private function expandNumericColumns(array &$columns, array &$columnNames) {        foreach ($columns as $column => $value) {     if (is_numeric($column)) { unset($columns[$column]); $columns[$columnNames[$column]] = $value; } } } public function insert(array $columns, $table = nil) {                                              $this->whichTable($table) ->setTable($table); $columnNames = $this->getColumnsForOperation($columns); $this->expandNumericColumns( $columns, $columnNames ); foreach ($columns as $column => $value) { if ($this->hasIncrementKey() && $this->primaryIncrementKeys[$table] == $column) { $columns[$column] = 'null'; } else { $columns[$column] = $this->getColumnValueSQL(nil, $column, false, $value); } } $sql = "INSERT INTO `{$this->hDatabaseInitial}`.`{$table}` (". hString::implodeToList($columnNames, ',', '`'). ") VALUES (". implode(',', $columns). ")"; if ($table != 'hErrorLog') { $this->lastQuery = $sql; } $this->query($sql); return $this->hasIncrementKey($table)? $this->getInsertedId() : 0; } public function save($columns, $table = nil) { $this->whichTable($table) ->setTable($table);                                                        $columns = $this->filterTableColumns($columns); $primaryColumn = $this->getPrimaryKey(); if (!empty($primaryColumn)) { if (empty($columns[$primaryColumn])) { return $this->insert($columns); } else { $where = array($primaryColumn => $columns[$primaryColumn]); if ($this->selectExists($primaryColumn, $table, $where)) { $this->update($columns, $where); return $columns[$primaryColumn]; } else { return $this->insert($columns); } } } else { $firstColumn = $this->getFirstColumn(); if (!empty($firstColumn)) { $where = array($firstColumn => $columns[$firstColumn]);   if ($this->selectExists($firstColumn, $table, $where)) { $this->update($columns, $where); } else { $this->insert($columns); } return $columns[$firstColumn]; } else { $GLOBALS['hFramework']->warning( "Error retrieving the first column for table '{$table}'.", __FILE__, __LINE__ ); } } } private function getColumnsForOperation(array &$columns, $table = nil) { $this->whichTable($table)->setTable($table)->getColumns($table); $columnNames = array_keys($columns); if (!$this->columnsInTable($columnNames) && isset($this->columns[$table]) && count($columnNames) == count($this->columns[$table])) { $columnNames = array_keys($this->columns[$table]); } return $columnNames; } public function filterTableColumns(array $columns, $table = nil) {           $this->whichTable($table); $columnsInTable = $this->getColumnNames($table); $filteredColumns = array(); if (is_array($columnsInTable) && count($columnsInTable)) { foreach ($columnsInTable as $columnInTable) { if (array_key_exists($columnInTable, $columns)) { $filteredColumns[$columnInTable] = $columns[$columnInTable]; } } if (!count($filteredColumns)) { if (count($columns) == count($columnsInTable)) {  $filteredColumns = array_combine( $columnsInTable, $columns ); } } return $filteredColumns; } else { $GLOBALS['hFramework']->warning( "Unable to retrieve columns for table '{$table}'.", __FILE__, __LINE__ ); } } public function columnsInTable(array $columns, $table = nil) { $this->whichTable($table); $tracker = true; foreach($columns as $column) { if (!empty($column)) { if (!$this->columnExists($column, $table)) { $tracker = false; } } } return $tracker; } public function columnInTable($column, $table = nil) { $this->whichTable($table) ->getColumns($table); return array_key_exists( $column, $this->columns[$table] ); } private function &whichTable(&$table) { if (empty($table)) { if (!empty($this->table)) { $table = $this->table; } else { $GLOBALS['hFramework']->warning( 'No default table is set.', __FILE__, __LINE__ ); } } if (!empty($table)) { if (!$this->tableExists($table)) { $backtrace = debug_backtrace(); $GLOBALS['hFramework']->warning( "Table '{$table}' does not exist, called in hDatabase::{$backtrace[2]['function']}(). ", __FILE__, __LINE__ ); } else { $this->getColumns($table); } } else { $GLOBALS['hFramework']->warning( 'No table could be selected.', __FILE__, __LINE__ ); } return $this; } public function &setTable($table, $value = nil) { $this->table = $table; if (!empty($value)) { $this->whichValue($value); } return $this; } public function refresh() { return $this->getTables(true); } public function getTables($refresh = false) { if (!count($this->tables) || $refresh) { $this->tables = array(); $this->firstColumns = array(); $this->primaryKeys = array(); $this->columns = array(); $this->primaryIncrementKeys = array(); $query = $this->query( "SHOW TABLES FROM `{$this->hDatabaseInitial}`" ); while ($data = $this->getNumberedResults($query)) { if (!in_array($data[0], $this->tables)) { array_push($this->tables, $data[0]); } } } return $this->tables; } public function tableExists($table) { return in_array($table, $this->tables); } private function &whichValue(&$value) {          if (empty($value)) { if (!empty($this->primaryKeyValue)) { $value = $this->primaryKeyValue; } else { $GLOBALS['hFramework']->warning( 'No default primary key value is set.', __FILE__, __LINE__ ); } } return $this; } public function &setPrimaryKeyValue($value) {            $this->primaryKeyValue = $value; return $this; } public function hasPrimaryKey($table = nil) {         $this->whichTable($table); return isset($this->primaryKeys[$table]); } public function isPrimaryKey($column, $table = nil) {         $this->whichTable($table); if ($this->hasPrimaryKey($table) && $this->primaryKeys[$table] == $column) { return true; } return false; } public function hasIncrementKey($table = nil) {         $this->whichTable($table); return isset($this->primaryIncrementKeys[$table]); } public function getPrimaryKey($table = nil) {         $this->whichTable($table); return isset($this->primaryKeys[$table])? $this->primaryKeys[$table] : ''; } public function getFirstColumn($table = nil) {        $this->whichTable($table); if (isset($this->firstColumns[$table])) { return $this->firstColumns[$table]; } else { $query = $this->getResults( "SHOW COLUMNS FROM `{$table}`" ); if (count($query)) { foreach ($query as $data) { $this->firstColumns[$table] = $data['Field']; return $this->firstColumns[$table]; } } else { $GLOBALS['hFramework']->warning( "Query Failed '{$query}'.", __FILE__, __LINE__ ); return false; } } return false; } public function &whichWhere(&$where, $table = nil) { $this->whichTable($table); if (empty($where)) { if (empty($this->where)) { if ($this->hasPrimaryKey($table)) { if ($this->primaryKeyValue) { $where = "`{$this->primaryKeys[$table]}` = '{$value}'"; } } } else { $where = $this->where; } } else { if (is_numeric($where)) { if ($this->hasPrimaryKey($table)) { $where = "`{$this->primaryKeys[$table]}` = ".$where; } else { $firstColumn = $this->getFirstColumn($table);  if (!empty($firstColumn)) { $where = "`{$firstColumn}` = ".$where; } else { $GLOBALS['hFramework']->warning( "Unable to determine a column to use for table '{$table}' ". "with value '{$where}'.", __FILE__, __LINE__ ); } } } } return $this; } private function &decideResultCount($sql) {             if (is_string($sql)) { $this->countType = strStr($sql, 'SQL_CALC_FOUND_ROWS')? '' : 'numRows'; } return $this; } private function &setResultCount($query = nil) {             $this->resultCount = $this->countType ? $this->getResultCount($query) : $this->getColumn("SELECT FOUND_ROWS()"); return $this; } public function getResultCount() {               return (int) $this->resultCount; } public function getAssociativeArray($sql, $prependValue = false, $prependString = '') {                                                            $this->decideResultCount($sql); $query = $this->query($sql); $this->setResultCount($query); $options = array(); if (!empty($prependValue)) { $options[0] = $prependString; } while ($data = $this->getNumberedResults($query)) { $options[$data[0]] = $data[1]; } $this->closeResults($query); return $options; } public function getResultsAsArray($sql, $index = nil) {        return $this->getResults($sql, $index); } public function getResults($sql, $index = nil) {                             if (empty($sql)) { return false; } $this->decideResultCount($sql); if (is_string($sql)) { $query = $this->query($sql); } else { $GLOBALS['hFramework']->warning( 'Unable to get database results because $sql was not a string. '. 'You probably meant to call select(). Now attempting to '. 'automatically reconcile this problem.', __FILE__, __LINE__ ); if (is_array($sql)) { $arguments = func_get_args(); return call_user_func_array( array( $this, 'select' ), $arguments ); } return $sql; } $columnCount = $this->getColumnCount(); $this->setResultCount($query); $results = array(); if (!empty($index)) { while ($data = $this->getAssociativeResults($query)) { $results[isset($data[$index])? $data[$index] : count($results)] = $data; } } else if ($columnCount > 1) { while ($data = $this->getAssociativeResults($query)) { array_push($results, $data); } } else { while ($data = $this->getNumberedResults($query)) { array_push($results, $data[0]); } } $this->closeResults($query); return $results; } public function getResultsForTemplate($results) {          if (is_array($results)) { if (count($results)) { $rtn = array(); foreach ($results as $i => $result) { if (is_array($result)) { foreach ($result as $key => $value) { $rtn[$key][] = $value; } } else { $GLOBALS['hFramework']->warning( "Get results for template failed!  Item '{$i}' is not an array.", __FILE__, __LINE__ ); } } if (isset($key) && isset($rtn[$key])) { $i = count($rtn[$key]); if (!empty($i)) { for ($c = 0; $c < $i; $c++) { $rtn['isOdd'][] = !($c & 1); } } } if ($GLOBALS['hFramework']->hFileGetMetaData(false) && (isset($rtn['hFileId']) || isset($rtn['hFileId']))) { return $this->getFileMetaDataForTemplate($rtn); } return $rtn; } return array(); } else if (!empty($results)) { return $this->getResultsForTemplate($this->getResults($results)); } else { return array(); } } public function implodeResults($sql, $glue = '') {          $query = $this->query($sql); $rtn = array(); while ($data = $this->getAssociativeResults($query)) { foreach ($data as $key => $value) { $rtn[] = $value; } } $this->closeResults($query); return implode($glue, $rtn); } public function getResult($sql, $default = '') {          return $this->getColumn($sql, $default); } public function getResultByKey($field, $table, $key, $keyValue, $default = '') {         return $this->getColumn( "SELECT `{$field}`
               FROM `{$table}`
              WHERE `{$key}` = ". (int) $keyValue, $default ); } public function getColumnType($column, $table = nil) {        $this->whichTable($table)->getColumns($table); if (isset($this->columns[$table][$column]['Type'])) { return $this->columns[$table][$column]['Type']; } else { $GLOBALS['hFramework']->warning( "No type is defined for column '{$column}' in table '{$table}'.", __FILE__, __LINE__ ); } } public function columnIsNumeric($column, $table = nil) {                      $this->whichTable($table); $bits = explode('(', $this->getColumnType($column, $table)); return in_array( strToLower( array_shift($bits) ), array( 'tinyint', 'smallint', 'mediumint', 'int', 'bigint', 'integer', 'dec', 'decimal', 'numeric', 'float', 'real' ) ); } public function getColumns($table) {          $table = trim($table); if (empty($table)) { $GLOBALS['hFramework']->warning( 'Unable to get columns for table because no table was provided.', __FILE__, __LINE__ ); return; } else { if (!isset($this->columns[$table]) || empty($this->columns[$table]) || !is_array($this->columns[$table]) || !count($this->columns[$table])) { $query = $this->getResults("SHOW COLUMNS FROM `{$table}`"); if (count($query)) { $i = 0; foreach ($query as $data) { if (!$i) { $this->firstColumns[$table] = $data['Field']; } $this->columns[$table][$data['Field']] = $data; if ($data['Key'] == 'PRI') { $this->primaryKeys[$table] = $data['Field']; } if ($data['Extra'] == 'auto_increment') { $this->primaryIncrementKeys[$table] = $data['Field']; } $i++; } } else { $GLOBALS['hFramework']->warning( "Query Failed '{$query}'.", __FILE__, __LINE__ ); } } } return $this->columns[$table]; } public function &uses() {             $arguments = func_get_args(); foreach ($arguments as $table) { if (!$this->tableExists($table)) { $this->createTableFromFile($table); } } return $this; } public function &createTableFromFile($table) {             if (!$this->tableExists($table)) { $path = $GLOBALS['hFramework']->hFrameworkPath.'/Hot Toddy/hDatabase/hDatabaseStructure/'.$table.'/'.$table.'.sql'; if (file_exists($path)) {  $this->query( file_get_contents($path) ); $GLOBALS['hFramework']->addTableObject($table); array_push($this->tables, $table); } } return $this; } public function getPostDataByColumnName($table, array $columns = array()) {             $columnsInTable = $this->getColumnNames($table); $data = array(); foreach ($columnsInTable as $column) { if (isset($_POST[$column]) && (count($columns) && in_array($column, $columns) || !count($columns))) { $data[$column] = $_POST[$column]; } } return $data; } public function getColumnNames($table) {        if (!isset($this->columns[$table])) { $this->getColumns($table); } return array_keys($this->columns[$table]); } public function &deleteTableCache($table) {             unset($this->firstColumns[$table]); unset($this->primaryKeys[$table]); unset($this->columns[$table]); unset($this->primaryIncrementKeys[$table]); foreach ($this->tables as $i => $tableName) { if ($tableName == $table) { unset($this->tables[$i]); } } return $this; } public function &addTableToCache($table) {             if (!in_array($table, $this->tables)) { array_push($this->tables, $table); } return $this; } public function &renameTableCache($oldName, $newName) {             foreach ($this->tables as $i => $table) { if ($tableName == $oldName) { $this->tables[$i] = $newName; break; } } if (isset($this->columns[$oldName])) { $this->columns[$newName] = $this->columns[$oldName]; unset($this->columns[$oldName]); } if (isset($this->firstColumns[$oldName])) { $this->firstColumns[$newName] = $this->firstColumns[$oldName]; unset($this->firstColumns[$oldName]); } if (isset($this->primaryKeys[$oldName])) { $this->primaryKeys[$newName] = $this->primaryKeys[$oldName]; unset($this->primaryKeys[$oldName]); } if (isset($this->primaryIncrementKeys[$oldName])) { $this->primaryIncrementKeys[$newName] = $this->primaryIncrementKeys[$oldName]; unset($this->primaryIncrementKeys[$oldName]); } return $this; } public function &deleteColumnCache($column, $table) {             if (isset($this->columns[$table])) { if (isset($this->columns[$table][$column])) { unset($this->columns[$table][$column]); } } if (isset($this->firstColumns[$table])) { if ($this->firstColumns[$table] == $column) { unset($this->firstColumns[$table]); $this->getFirstColumn($table); } } if (isset($this->primaryKeys[$table])) { if ($this->primaryKeys[$table] == $column) { unset($this->primaryKeys[$table]); } } if (isset($this->primaryIncrementKeys[$table])) { if ($this->primaryIncrementKeys[$table] == $column) { unset($this->primaryIncrementKeys[$table]); } } return $this; } public function &renameColumnCache($oldName, $newName, $table) {             if (isset($this->columns[$table])) { if (isset($this->columns[$table][$oldName])) { $copy = array();  foreach ($this->columns[$table] as $column => $data) { if ($column == $oldName) { $copy[$newName] = $data; } else { $copy[$column] = $data; } } $this->columns[$table] = $copy; } } if (isset($this->firstColumns[$table])) { if ($this->firstColumns[$table] == $oldName) { $this->firstColumns[$table] = $newName; } } if (isset($this->primaryKeys[$table])) { if ($this->primaryKeys[$table] == $oldName) { $this->primaryKeys[$table] = $newName; } } if (isset($this->primaryIncrementKeys[$table])) { if ($this->primaryIncrementKeys[$table] == $oldName) { $this->primaryIncrementKeys[$table] = $newName; } } return $this; } public function isAutoIncrementColumn($column, $table = nil) {           $this->whichTable($table); if (!empty($table)) { if (!isset($this->primaryIncrementKeys[$table])) { $this->getColumns($table); } if (isset($this->primaryIncrementKeys[$table])) { return strToLower($this->primaryIncrementKeys[$table]) == strToLower($column); } } return false; } private function whichColumnExists($column, $table) { } } ?>