<?php
  class hSmartyPantsLibrary extends hPlugin { private $attribute = 1; private $tagsToSkip = '<(/?)(?:pre|code|kbd|script|math)[\s>]'; public function modifier($text, $attribute = null) { return $this->get($text, $attribute); } public function get($text, $attribute = null) { if (empty($attribute)) { $attribute = $this->attribute; } if (empty($attribute)) { return $text; } $stupefy = false; $convertQuotes = false; switch ($attribute) { case 1: { $quotes = 1; $backticks = 1; $dashes = 1; $ellipses = 1; break; } case 2: { $quotes = 1; $backticks = 1; $dashes = 2; $ellipses = 1; break; } case 3: { $quotes = 1; $backticks = 1; $dashes = 3; $ellipses = 1; break; } case -1: { $stupefy = 1; break; } default: { $characters = preg_split('//', $attribute); foreach ($characters as $character) { switch ($character) { case 'q': { $quotes = 1; break; } case 'b': { $backticks = 1; break; } case 'B': { $backticks = 2; break; } case 'd': { $dashes = 1; break; } case 'D': { $dashes = 2; break; } case 'i': { $dashes = 3; break; } case 'e': { $ellipses = 1; break; } case 'w': { $convertQuotes = true; break; } } } } } $tokens = $this->tokenizeHTML($text); $result = ''; $inPreFormatted = false; $previousTokenCharacter = ''; foreach ($tokens as $token) { if ($token[0] == 'tag') { $result .= $token[1]; if (preg_match("@{$this->tagsToSkip}@", $token[1], $matches)) { $inPreFormatted = !(isset($matches[1]) && $matches[1] == '/'); } } else { $token = $token[1]; $lastCharacter = substr($token, -1); if (!$inPreFormatted) { $token = $this->processEscapes($token); if ($convertQuotes) { $token = preg_replace('/&quot;', '"', $token); } if ($dashes) { switch ($dashes) { case 1: { $token = $this->educateDashes($token); break; } case 2: { $token = $this->educateDashesOldSchool($token); break; } case 3: { $token = $this->educateDashesOldSchoolInverted($token); break; } } } if ($ellipses) { $token = $this->educateEllipses($token); } if ($backticks) { $token = $this->educateBackticks($token); if ($backticks == 2) { $token = $this->educateSingleBackticks($token); } } if ($quotes) { if ($token == "'") {  if (preg_match('/\S/', $previousTokenCharacter)) { $token = '&rsquo;'; } else { $token = '&lsquo;'; } } else if ($token == '"') {  if (preg_match('/\S/', $previousTokenCharacter)) { $token = '&rdquo;'; } else { $token = '&ldquo;'; } } else {  $token = $this->educateQuotes($token); } } if ($stupefy) { $token = $this->stupefyEntities($token); } } $previousTokenCharacter = $lastCharacter; $result .= $token; } }  return str_ireplace( array( '(c)', '(r)', '(tm)', ), array( '&copy;', '&reg;', '&trade;' ), $result ); } public function smartDashes($text, $attribute = null) { if (empty($attribute)) { $attribute = $this->attribute; } if (empty($attribute)) { return $text; }  $dashMethod = 'educateDashes'; switch ($attribute) { case 2: { $dashMethod = 'educateDashesOldSchool'; break; } case 3: { $dashMethod = 'educateDashesOldSchoolInverted'; break; } } $tokens = $this->tokenizeHTML($text); $result = ''; $inPreFormatted = false;  foreach ($tokens as $token) { if ($token[0] == 'tag') {  $result .= $token[1]; if (preg_match("@{$this->tagsToSkip}@", $token[1], $matches)) { $inPreFormatted = !(isset($matches[1]) && $matches[1] == '/'); } } else { $token = $token[1]; if (!$inPreFormatted) { $token = $this->processEscapes($token); $token = $this->{"{$dashMethod}"}($token); } $result .= $token; } } return $result; } public function smartEllipses($text, $attribute = null) {  if (empty($attribute)) { $attribute = $this->attribute; } if (empty($attribute)) {  return $text; } $tokens = $this->tokenizeHTML($text); $result = ''; $inPreFormatted = false;  foreach ($tokens as $token) { if ($token[0] == 'tag') {  $result .= $token[1]; if (preg_match("@{$this->tagsToSkip}@", $token[1], $matches)) { $inPreFormatted = !(isset($matches[1]) && $matches[1] == '/'); } } else { $token = $token[1]; if (!$inPreFormatted) { $token = $this->processEscapes($token); $token = $this->educateEllipses($token); } $result .= $token; } } return $result; } public function smartQuotes($text, $attribute = null) { if (empty($attribute)) { $attribute = $this->attribute; } if (empty($attribute)) {  return $text; } $doBackticks = false; if ($attribute == 2) {  $doBackticks = true; }    $addExtraSpace = false; if (preg_match("/>['\"]\\z/", $text)) { $addExtraSpace = true;  $text .= ' '; } $tokens = $this->tokenizeHTML($text); $result = ''; $inPreFormatted = false;  $previousTokenCharacter = '';     foreach ($tokens as $token) { if ($token[0] == 'tag') {  $result .= $token[1]; if (preg_match("@{$this->tagsToSkip}@", $token[1], $matches)) { $inPreFormatted = !(isset($matches[1]) && $matches[1] == '/'); } } else { $token = $token[1]; $lastCharacter = substr($token, -1);  if (!$inPreFormatted) { $token = $this->processEscapes($token); if ($doBackticks) { $token = $this->educateBackticks($t); } if ($token == "'") {  if (preg_match('/\S/', $previousTokenCharacter)) { $token = '&rsquo;'; } else { $token = '&lsquo;'; } } else if ($token == '"') {  if (preg_match('/\S/', $previousTokenCharacter)) { $token = '&rdquo;'; } else { $token = '&ldquo;'; } } else {  $token = $this->educateQuotes($token); } } $previousTokenCharacter = $lastCharacter; $result .= $token; } } if ($addExtraSpace) { preg_replace('/ \z/', '', $result);  } return trim($result); } private function tokenizeHTML($string) {             $index = 0; $tokens = array(); $parts = preg_split( '{('. '(?s:<!(?:--.*?--\s*)+>)|'.  '(?s:<\?.*?\?>)|'.   '(?:<[/!$]?[-a-zA-Z0-9:]+\b(?>[^"\'>]+|"[^"]*"|\'[^\']*\')*>)'. ')}', $string, -1, PREG_SPLIT_DELIM_CAPTURE ); foreach ($parts as $part) { if (++$index % 2 && !empty($part)) { $tokens[] = array('text', $part); } else { $tokens[] = array('tag', $part); } } return $tokens; }     public function processEscapes($string) { return str_replace( array( '\\\\', '\"', "\'", '\.', '\-', '\`' ), array( '&#92;',  '&quot;',  '&apos;',  '&#46;',  '&#45;',  '&#96;'  ), $string ); }       public function stupefyEntities($string) { return str_ireplace( array( '&#8211;', '&ndash;', '&#x2013;', '&#8212;', '&mdash;', '&#x2014;', '&#8216;', '&lsquo;', '&#x2018;', '&#8217;', '&rsquo;', '&#x2019;', '&#8220;', '&ldquo;', '&#x201C;', '&#8221;', '&rdquo;', '&#x201D;', '&#8230;', '&hellip;', '&#x2026;' ), array( '-', '-', '-', '--', '--', '--', "'", "'", "'", "'", "'", "'", '"', '"', '"', '"', '"', '"', '...', '...', '...' ), $string ); }    public function educateBackticks($string) { return str_replace( array( "``", "''", ), array( '&ldquo;', '&rdquo;' ), $string ); }    function educateSingleBackticks($string) { return str_replace( array( "`", "'", ), array( '&lsquo;', '&rsquo;' ), $string ); }     public function educateDashes($string) { return str_replace('--', '&mdash;', $string); }      public function educateDashesOldSchool($string) { return str_replace( array( "---", "--", ), array( '&mdash;', '&ndash;' ), $string ); }             public function educateDashesOldSchoolInverted($string) { return str_replace( array( '---', '--', ), array( '&ndash;', '&mdash;' ), $string ); }     public function educateEllipses($string) { return str_replace( array( "...", ". . ." ), '&hellip;', $string ); }   public function educateQuotes($string) {   $punctuationClass = "[!\"#\\$\\%'()*+,-.\\/:;<=>?\\@\\[\\\\\]\\^_`{|}~]";   $string = preg_replace( array( "/^'(?={$punctuationClass}\\B)/", "/^\"(?={$punctuationClass}\\B)/" ), array( '&rsquo;', '&rdquo;' ), $string );   $string = preg_replace( array( "/\"'(?=\w)/", "/'\"(?=\w)/" ), array( '&ldquo;&lsquo;', '&lsquo;&ldquo;' ), $string );  $string = preg_replace( "/'(?=\\d{2}s)/", '&rsquo;', $string ); $closeClass = '[^\ \t\r\n\[\{\(\-]'; $decimalDashes = '&ndash;|&mdash;';  $string = preg_replace( "{(
                    \\s |              # a whitespace char, or
                    &nbsp; |           # a non-breaking space entity, or
                    -- |               # dashes, or
                    &[mn]dash; |       # named dash entities
                    {$decimalDashes} | # or decimal entities
                    &\\#x201[34];      # or hex
                )'                     # the quote
                (?=\\w)                # followed by a word character
            }xi", '\1&lsquo;', $string );  $string = preg_replace( "{
                ({$closeClass})?
                '
                (?(1)|          # If \$1 captured, then do nothing;
                (?=\\s | s\\b)  # otherwise, positive lookahead for a whitespace
                )               # char or an 's' at a word ending position. This
                                # is a special case to handle something like:
                                # \"<i>Custer</i>'s Last Stand.\"
            }xi", '\1&rsquo;', $string );  $string = str_replace("'", '&lsquo;', $string);  $string = preg_replace( "{
                (
                    \\s |              # a whitespace char, or
                    &nbsp; |           # a non-breaking space entity, or
                    -- |               # dashes, or
                    &[mn]dash; |       # named dash entities
                    {$decimalDashes} | # or decimal entities
                    &\\#x201[34];      # or hex
                )
                \"                     # the quote
                (?=\\w)                # followed by a word character
            }ix", '\1&ldquo;', $string );  $string = preg_replace( "{
                ({$closeClass})?
                \"
                (?(1)|(?=\\s))   # If \$1 captured, then do nothing;
                                 # if not, then make sure the next char is whitespace.
            }ix", '\1&rdquo;', $string );  return str_replace('"', '&ldquo;', $string); } } ?>