<?php
   class hTemplate extends hPlugin { private $hTemplateLanguage; private $templateVariables; private $template; private $matchCurlyBraces = "/\{([^{}]+|(?R))*\}/";  private $templateCache = array(); public function setDocumentTemplate() {                                               if ($this->hShellCLI(false)) { return; } $path = $this->hFilePath; do {  $templateId = $this->hDatabase->selectColumn( array( 'hTemplateDirectories' => 'hTemplateId' ), array( 'hTemplateDirectories', 'hDirectories' ), array( 'hDirectories.hDirectoryPath' => $path, 'hTemplateDirectories.hDirectoryId' => 'hDirectories.hDirectoryId' ) ); if (!empty($templateId) || $path == '/') { break; } } while ($path = dirname($path)); $this->hTemplateId = !empty($templateId)? (int) $templateId : $this->hTemplateId(1); $this->setVariables( $this->hTemplates->selectAssociative( array( 'hTemplateId', 'hTemplatePath', 'hTemplateName', 'hTemplateDescription' ), (int) $this->hTemplateId ) ); } public function getTemplate($path, $variables = array()) {                    $path = $this->insertSubExtension( $path, 'mobile', $this->userAgent->interfaceIdiomIsPhone ); if (file_exists($path)) { $this->addLoadedPath('Template: '.$path); if (!isset($this->templateCache[$path])) { $this->template = file_get_contents($path); $this->templateCache[$path] = $this->template; } else { $this->template = $this->templateCache[$path]; } return $this->parseTemplate( $this->template, $variables, $path ); } else { $this->warning( "The template path '{$path}' does not exist in template '{$this->templatePath}'.", __FILE__, __LINE__ ); return ''; } } public function parseTemplate($document, $variables = array(), $path = null, $templateName = '') {                            $openingCount = substr_count($document, '{'); $closingCount = substr_count($document, '}'); if ($openingCount < $closingCount) { $this->notice( "The template document could not be parsed because it is missing an opening '{' symbol.", __FILE__, __LINE__ ); } if ($openingCount > $closingCount) { $this->notice( "The template document could not be parsed because it is missing a closing '}' symbol.", __FILE__, __LINE__ ); } if (empty($path)) { $this->templatePath = $templateName? $templateName : "Generic Template Document"; } else { $this->templatePath = $path; } if (!$this->userAgent->browser) { $this->userAgent->browser = 'webkit'; } if (!isset($GLOBALS['hTemplateVariables']) || !is_array($GLOBALS['hTemplateVariables'])) { $GLOBALS['hTemplateVariables'] = array(); } foreach ($variables as $key => $value) { $GLOBALS['hTemplateVariables'][$key] = $value; }   $GLOBALS['hTemplateVariables'] = array_merge( $this->getVariables(), $GLOBALS['hTemplateVariables'] ); $document = preg_replace_callback( $this->matchCurlyBraces, array($this, 'parse'), $document ); $GLOBALS['hTemplateVariables'] = array(); return $document; } public function setTemplateVariable($key, $value) {              $GLOBALS['hTemplateVariables'][$key] = $value; } public function walkTemplateObject(&$object, array $variables = array()) { foreach ($object as $key => &$value) { if (is_object($value) || is_array($value)) { $this->walkTemplateObject($value, $variables); } else { $value = $this->parseTemplateMarkup($value, $variables); } } } public function parseTemplateMarkup($document, array $variables = array()) {         return $this->parseTemplate($document, $variables); } public function parse($matches) { $block = substr($matches[0], 1, -1);                         if (substr($block, 0, 1) == '#') { return ''; }            if (substr($block, 0, 1) == '/' || substr($block, 0, 1) == '\\') { return '&#123;'.substr($block, 1).'&#125;'; }                                                         preg_match( '/'.  '^'.  'compile[\.|\:]'.  '(js|css){1}\:'.  '(.*)'.  '$'.  '/'.  'sm',  $block, $blockMatches ); if (!empty($blockMatches[1])) { $type = $blockMatches[1]; $json = $this->decodeJSON( $blockMatches[2] ); if (isset($json->master) && isset($json->files) && is_array($json->files)) { $name = basename($json->master); $compiledDirectory = $this->hFrameworkCompiledPath; if (!file_exists($compiledDirectory)) { $this->console("Making directory {$compiledDirectory}"); $this->mkdir( $compiledDirectory ); } $destinationPath = $compiledDirectory.'/'.$name; $destinationExists = file_exists( $destinationPath ); $recompile = false; if ($destinationExists) { $mtime = filemtime($destinationPath); if ($mtime < filemtime($this->hServerDocumentRoot).$json->master) { $recompile = true; } else { foreach ($json->files as $file) { if (!file_exists($this->hServerDocumentRoot.$file)) { $this->warning( "Unable to include a file in a complication for '{$name}' because the file '{$file}' does not exist.", __FILE__, __LINE__ ); } else if (filemtime($this->hServerDocumentRoot.$file) > $mtime) { $recompile = true; break; } } } } $compiled = ''; if (!$destinationExists || $recompile) { foreach ($json->files as $file) { if (!file_exists($this->hServerDocumentRoot.$file)) { $this->warning( "Unable to include a file in a complication for '{$name}' because the file '{$file}' does not exist.", __FILE__, __LINE__ ); } else { $compiled .= file_get_contents( $this->hServerDocumentRoot.$file ); } } file_put_contents( $destinationPath, $compiled ); } $content = !empty($compiled)? $compiled : file_get_contents($destinationPath); switch ($type) { case 'js': { return $content; } case 'css': { return $this->parseTemplate($content); } } } else { $this->warning( "Unable to compile {$type} because the JSON configuration is not correctly formatted.", __FILE__, __LINE__ ); } }                     preg_match( '/'.  '^'.  '[\$|\w|\d|\.]{1,}'.  '$'.  '/'.  'U',  $block, $blockMatches ); if (!empty($blockMatches[0])) { return $this->getTemplateVariable($blockMatches[0]); } preg_match( '/'.  '^'.  '(EncodeHTML)'.  '(\?|\:)'.  '(.*)'.  '$'.  '/'.  'ism',  $block, $blockMatches ); if (count($blockMatches)) { return htmlspecialchars( $blockMatches[3], ENT_QUOTES ); }                                                 preg_match( '/'.  '^'.  '(\!|\?|\@|\&)?'.  '([\$|\w|\d|\.]{1,})'.  '(\?'.  '(.*)'.  '){0,}'.  '$'.  '/'.  'sm',  $block, $blockMatches ); if (!empty($blockMatches[2]) && isset($blockMatches[4])) { $operator = $blockMatches[1]; $variable = $blockMatches[2]; $this->getTemplateVariableName($variable); $content = $blockMatches[4]; $result = eval("return({$variable});"); return $this->getContentByOperator( $operator, $result, $content, $variable ); }           preg_match( '/^[\$]?(hFileId\:|fileId\:)(\d*)$/i', $block, $blockMatches ); if (!empty($blockMatches[2])) { return $this->getFilePathByFileId((int) $blockMatches[2]); }                   preg_match( '/^([\$|\w|\d|\.]+)\s*(\=)\s*(.*)$/Ums', $block, $blockMatches ); if (isset($blockMatches[2]) && $blockMatches[2] == '=') { $this->assignTemplateVariable( $blockMatches[1], preg_replace_callback( $this->matchCurlyBraces, array( $this, 'parse' ), trim($blockMatches[3]) ) ); return ''; }                 preg_match( '/^([\$|\w|\d|\.]+)\s*(\+\+|\-\-)?$/', $block, $blockMatches ); if (isset($blockMatches[2])) { switch ($blockMatches[2]) { case '++': { $this->incrementTemplateVariable($blockMatches[1]); break; } case '--': { $this->decrementTemplateVariable($blockMatches[1]); break; } } return ''; } $strings = array( 'user.', 'contact.', 'string.', 'hot.', 'php.', '.' ); if (false !== ($beginning = $this->beginsString($block, $strings))) {                                                                                                                               preg_match( '/^(\!|\?|\@|\&)?(.*?)(\(([^()]+|(?R))*\))(\?(.*)){0,}$/sm', $block, $blockMatches ); $operator = $blockMatches[1]; $content = $blockMatches[6]; $bits = explode('.', $blockMatches[2]); $method = array_pop($bits); if ($beginning == 'php.' && $method == 'version') { $method = 'phpversion'; } $originalMethod = $method; $expression = $this->getWithTemplateVariableNames($blockMatches[3]); $expression = preg_replace_callback( $this->matchCurlyBraces, array( $this, 'parse' ), $expression ); $method .= $expression; $result = null; switch ($beginning) { case 'user.': { $string = '$GLOBALS[\'hFramework\']->user->'.$method; break; } case 'contact.': { $string = '$GLOBALS[\'hFramework\']->contact->'.$method; break; } case 'string.': { $string = 'hString::'.$method; break; } case 'php.': { if (!function_exists($originalMethod) && $originalMethod != 'empty' && $originalMethod != 'isset') { $this->notice( "Execution of php function '{$originalMethod}' failed in template '{$this->templatePath}'.", __FILE__, __LINE__ ); return ''; } $string = $method; break; } case 'hot.': case '.': default: { $string = '$GLOBALS[\'hFramework\']->'.$method; } } $result = eval("return ({$string});"); if (!empty($blockMatches[5])) { return $this->getContentByOperator( $operator, $result, $content ); } else { return $result; } }                                                               preg_match( '/'. '^'. 'include\:('. 'encodeHTML\:|'. 'encode\:|'. 'fileId\:|'. 'hFileId\:|'. 'hFilePath\:|'. 'filePath\:'. ')?'. '('. 'fileId\:|'. 'hFileId\:|'. 'hFilePath\:|'. 'filePath\:'. ')?'. '(.*)'. '$'. '/'. 'i', $block, $blockMatches ); if (!empty($blockMatches[0])) { $path = trim($blockMatches[3]); if (substr($path, 0, 1) == '{') { $path = preg_replace_callback( $this->matchCurlyBraces, array( $this, 'parse' ), $path ); } $type = strtolower($blockMatches[1]); $framework = strtolower($blockMatches[2]); if ($type == 'fileid:' || $type == 'hfileid:' || $type == 'hfilepath:') { return $this->getFrameworkFile($path); } if ($framework == 'fileid:' || $framework == 'hfileid:' || $framework == 'hfilepath:') { $file = $this->getFrameworkFile($path); } else { if (file_exists($path)) { $file = file_get_contents($path); } else if (file_exists($this->hServerDocumentRoot.$path)) { $file = file_get_contents($this->hServerDocumentRoot.$path); } else if (file_exists($this->hFrameworkPath.$path)) { $file = file_get_contents($this->hFrameworkPath.$path); } else if (file_exists($this->hTemplateIncludePath.$path)) { $file = file_get_contents($this->hTemplateIncludePath.$path); } else { $this->notice( "Failed to include path '{$path}' in template '{$this->templatePath}' because it does not exist.", __FILE__, __LINE__ ); } } if (isset($file)) { $file = $this->recursiveParse($file); switch ($type) { case 'encode:': case 'encodehtml:': { return htmlspecialchars($file); } default: { return $file; } } } }       preg_match( '/'.  '^'.  '([\$|\w|\d|\.]+)'.  '[\:|.](each)[\||\(]'.  '\s*'.  '([\$|\w|\d|\.]+)'.  '(\s*\,{1}\s*){0,1}'.  '([\$|\w|\d|\.]+){0,1}'.  '\s*'.  '[\||\)]'.  '\?'.  '(.*)'.  '$'.  '/'.  'sm',  $block, $blockMatches ); if (count($blockMatches)) { $templateVariable = $this->getTemplateVariable($blockMatches[1]); if (is_array($templateVariable) || is_object($templateVariable)) { $operation = $blockMatches[2];  $leftVariable = $blockMatches[3]; $rightVariable = $blockMatches[5];     $block = $blockMatches[6]; $builtBlock = ''; foreach ($templateVariable as $key => $value) { if (empty($rightVariable)) { $this->setTemplateVariable($leftVariable, $value); } else { $this->setTemplateVariable($leftVariable, $key); $this->setTemplateVariable($rightVariable, $value); } $builtBlock .= $this->recursiveParse($block); } return $this->recursiveParse($builtBlock); } else { return ''; } }                                                                                                 preg_match( '/^(\!)?([\$|\w|\d|\.]+)\[\]\?(.*)$/sm', $block, $blockMatches ); if (!empty($blockMatches[2])) { $not = $blockMatches[1]; $array = $this->getTemplateVariable($blockMatches[2]); $block = $blockMatches[3]; if (is_array($array) && count($array)) { $builtBlock = ''; $count = 1; while ($count) { $templateVariables = array(); foreach ($array as $key => $value) { $templateVariables[$key] = array_shift($array[$key]); $count = count($array[$key]); } foreach ($templateVariables as $key => $value) { $this->setTemplateVariable($key, $value); } $builtBlock .= $this->recursiveParse($block); } return $this->recursiveParse($builtBlock); } else { return ''; } }                   preg_match( '/^(\!|\?|\@|\&)?(\(([^()]+|(?R))*\))(\?(.*)){0,}$/sm', $block, $blockMatches ); if (!empty($blockMatches[2])) { $operator = $blockMatches[1]; $syntax = trim($blockMatches[2]); $content = $blockMatches[5]; if (substr($syntax, 0, 1) == '(' && substr($syntax, -1, 1) == ')') { $syntax = $this->getWithTemplateVariableNames($syntax); $result = eval("return{$syntax};"); return $this->getContentByOperator( $operator, $result, $content, $syntax ); } }                                                                          preg_match( '/^userAgent(\:(\!*)\((.*)\))*\:(\!*)\((\w*)\s*((\!|\>|\<|\=)*)\s*((\d|\.)*)\)\?(.*)$/ism', $block, $blockMatches ); if (count($blockMatches) && !empty($blockMatches[0])) {        $notOS = !empty($blockMatches[2]); $OS = $blockMatches[3]; $not = !empty($blockMatches[4]); $userAgent = trim($blockMatches[5]); if (strstr($userAgent, ',')) { list($os, $userAgent) = explode(',', $userAgent); $os = trim($os); $userAgent = trim($os); } $operator = $blockMatches[6]; $version = (float) $blockMatches[8]; $block = $blockMatches[10]; $isVersion = false; if (!empty($OS)) { if ($this->userAgent->os == $OS) { $isVersion = !$notOS; } else if ($notOS) { $isVersion = true; } } if (!empty($userAgent) && ($isVersion && !empty($OS) || !$isVersion && empty($OS))) { if ($userAgent == $this->userAgent->browser) { if (!empty($version)) { if (!empty($operator)) { switch ($operator) { case '>': case '<': case '>=': case '>=': case '!=': case '<>': case '==': { break; } default: { $operator = '=='; } } } else { $operator = '=='; } $rtn = eval("return ((float) {$this->userAgent->browserVersion} {$operator} (float) {$version});"); $isVersion = ($rtn && !$not || !$rtn && $not); } else { $isVersion = !$not; } } else if ($not) { $isVersion = true; } else { $isVersion = false; } } if ($isVersion) { return $this->recursiveParse($block); } return ''; }  return '{'.$this->recursiveParse($block).'}'; } public function recursiveParse($block) {         return preg_replace_callback( $this->matchCurlyBraces, array( $this, 'parse' ), $block ); } private function getContentByOperator($operator, $result, $content, $syntax = '') {                                                                                  switch ($operator) { case '!': { return empty($result)? $this->recursiveParse($content) : ''; } case '?': { return empty($result)? $this->recursiveParse($content) : $result; } case '@': { if (!empty($syntax)) { $isset = eval("return(isset({$syntax}))"); if ($isset) { return $result; } } return ''; } case '&': { return !empty($result)? $result.$this->recursiveParse($content) : ''; } default: { return !empty($result)? $this->recursiveParse($content) : ''; } } } private function getFrameworkFile($path) {          if (is_numeric($path) && !$this->getFilePathByFileId($path)) { $this->notice( "Failed to include hFileId '{$path}' in template '{$this->templatePath}' ". "because it does not exist.", __FILE__, __LINE__ ); } else if (!$this->getFileIdByFilePath($path)) { $this->notice( "Failed to include hFilePath '{$path}' in template '{$this->templatePath}' ". "because it does not exist.", __FILE__, __LINE__ ); } return $this->getFileDocument($path); } private function templateVariableExists($variable) {        $exists = eval("return(isset({$variable}));");     } private function getWithTemplateVariableNames($string) {         return preg_replace_callback( $this->matchCurlyBraces, array( $this, 'expandTemplateVariables' ), $string ); } public function expandTemplateVariables($matches) {         preg_match( '/^[\$|\w|\d|\.]{1,}$/U', $matches[1], $varMatches ); $this->getTemplateVariableName($varMatches[0]); return $varMatches[0]; } private function getTemplateVariableName(&$variable) {                                 $originalVariable = $variable; $variable = str_replace('$', '', $variable); preg_match( '/^(post|get|server|env|cookie|session|globals|global)\./', $variable, $superGlobalMatches ); if (!empty($superGlobalMatches[1])) {          $superGlobal = $superGlobalMatches[1]; $underscore = ($superGlobal != 'global' && $superGlobal != 'globals'); $this->convertDotsToBrackets($variable); $variable = substr_replace( $variable, '$'.($underscore? '_' : '').strtoupper($superGlobal == 'global'? 'globals' : $superGlobal), 0, strlen($superGlobal) ); } else if (strpos($variable, '.')) { if (substr($variable, 0, strlen('userAgent.')) == 'userAgent.') {   $variable = '$GLOBALS[\'hFramework\']->'.str_replace('.', '->', $variable); } else {      $variables = explode('.', $variable); $variableString = '$GLOBALS[\'hTemplateVariables\']'; foreach ($variables as $variable) { if (eval("return(is_object($variableString));")) { $variableString .= "->{$variable}"; } else { if (is_numeric($variable)) { $variableString .= "[{$variable}]"; } else { $variableString .= "['{$variable}']"; } } } $variable = $variableString; } } else {   $variable = '$GLOBALS[\'hTemplateVariables\'][\''.$variable.'\']'; } $this->templateVariableExists($variable); } private function convertDotsToBrackets(&$variable, $all = false) {             if (!$all) { $variable = substr_replace($variable, "['", strpos($variable, '.'), 1); } $variable = str_replace('.', "']['", $variable); $variable = ($all? "['" : '').$variable."']"; } private function getTemplateVariable($variable) {                      $this->getTemplateVariableName($variable); return eval("return(isset({$variable})? {$variable} : '');"); } private function assignTemplateVariable($variable, $value) {                    $this->getTemplateVariableName($variable); $value = trim($value); $firstCharacter = substr($value, 0, 1); $lastCharacter = substr($value, -1, 1); $quotedString = $this->isQuote($firstCharacter) && $this->isQuote($lastCharacter); if (!is_numeric($value) && $value != 'true' && $value != 'false' && !$quotedString) { $value = '"'.str_replace('"', '\\"', $value).'"'; } if ($firstCharacter == '"' && $lastCharacter == '"') { $value = preg_replace_callback( $this->matchCurlyBraces, array( $this, 'parse' ), $value ); } if ($firstCharacter == '{' && $lastCharacter == '}') { $value = preg_replace_callback( $this->matchCurlyBraces, array( $this, 'parse' ), $value ); if (!is_numeric($value)) { $value = '"'.str_replace('"', '\\"', $value).'"'; } } eval("{$variable} = {$value};"); } private function isQuote($string) {         return $string == '"' || $string == "'"; } private function incrementTemplateVariable($variable) {            $this->getTemplateVariableName($variable); return eval("isset({$variable})? ++{$variable} : ({$variable} = 0);"); } private function decrementTemplateVariable($variable) {            $this->getTemplateVariableName($variable); return eval("isset({$variable})? --{$variable} : ({$variable} = 0);"); } public function matchArrayBrackets($matches) {          if (is_numeric($matches[3])) { return '['.$matches[3].']'; } return $matches[0]; } public function beginsString($string, $beginnings) {                                              $beginsString = ( substr($string, 0, 1) == '!' || substr($string, 0, 1) == '?' || substr($string, 0, 1) == '@' || substr($string, 0, 1) == '&' ); if ($beginsString) { $string = substr($string, 1); } if (is_array($beginnings)) { foreach ($beginnings as $beginning) { if (substr($string, 0, strlen($beginning)) == $beginning) { return $beginning; } } } else if (substr($string, 0, strlen($beginnings)) == $beginnings) { return $beginning; } return false; } } ?>