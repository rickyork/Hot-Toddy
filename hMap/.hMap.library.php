<?php
  abstract class hMapInterface extends hPlugin { private $hJSON; abstract public function hConstructor(array $arguments = array());  abstract public function getCoordinates($query);  abstract public function getAddressCoordinates($address);  abstract public function getZipCodeCoordinates($zipCode);  abstract public function getCityCoordinates($city); } class hMapLibrary extends hPlugin { private $hLocation; private $hLocationCity; private $hMapService; private $serviceName; public function hConstructor($arguments = array()) { if (isset($arguments['serviceName'])) { $this->serviceName = $arguments['serviceName']; } else { $this->serviceName = $this->hMapServiceName('google'); } switch ($this->serviceName) { case 'google': { $this->hMapService = $this->library('hMap/hMapService/hMapServiceGoogle'); break; } default: { if (!$this->hMapServiceName && $this->hMapServicePlugin) { $this->hMapService = $this->library($this->hMapServicePlugin); } } } $this->hLocationCity = $this->library('hLocation/hLocationCity'); $this->hLocation = $this->library('hLocation'); } public function getCoordinates($query) {                      return $this->hMapService->getCoordinates($query); } public function getAddressCoordinates($contactAddressId) {                        if (!empty($contactAddressId)) { $exists = $this->hContactAddresses->selectExists('hContactAddressId', $contactAddressId); if ($exists) { $address = $this->hContactAddresses->selectAssociative('*', $contactAddressId); if (!empty($address['hContactAddressLatitude']) && !empty($address['hContactAddressLongitude']) && $this->hMapCacheDisabled(false)) { return array( 'latitude' => (float) $address['hContactAddressLatitude'], 'longitude' => (float) $address['hContactAddressLongitude'] ); }   $template = $this->hContactAddressTemplates->selectColumn( 'hContactAddressTemplate', $this->hLocationCountries->selectColumn( 'hContactAddressTemplateId', $address['hLocationCountryId'] ) ); $state = ''; if (!empty($address['hLocationStateId'])) { $useStateCode = (int) $this->hLocationCountries->selectColumn( 'hLocationUseStateCode', $address['hLocationCountryId'] ); $state = $this->hLocationStates->selectColumn( $useStateCode? 'hLocationStateCode' : 'hLocationStateName', $address['hLocationStateId'] ); } $country = $this->hLocationCountries->selectColumn( 'hLocationCountryName', $address['hLocationCountryId'] ); $address = str_replace( array( '{$street}', '{$city}', '{$state}', '{$postalCode}', '{$country}', '|' ), array( str_replace("\n", ', ', $address['hContactAddressStreet']), $address['hContactAddressCity'], $state, $address['hContactAddressPostalCode'], $country, ', ' ), $template ); $coordinates = $this->hMapService->getAddressCoordinates($address); if ($coordinates !== false) { if (isset($coordinates['latitude']) && isset($coordinates['longitude'])) { $this->hContactAddresses->update( array( 'hContactAddressLatitude' => (float) $coordinates['latitude'], 'hContactAddressLongitude' => (float) $coordinates['longitude'] ), $contactAddressId ); return array( 'latitude' => (float) $coordinates['latitude'], 'longitude' => (float) $coordinates['longitude'] ); } else { $this->warning( "Map service '{$this->serviceName}' did not provide latitude and longitude ". "coordinates for address: '{$address}'", __FILE__, __LINE__ ); } } else { $this->notice( "Map service '{$this->serviceName}' did not successfully query ". "coordinates for address: '{$address}'", __FILE__, __LINE__ ); } } else { $this->notice( "Map service was not able to provide coordinates for contactAddressId: ". "'{$contactAddressId}', because it does not exist.", __FILE__, __LINE__ ); } } else { $this->notice( "Map service was not able to provide address coordinates because no ". "contactAddressId was provided.", __FILE__, __LINE__ ); } return array(); } public function getAddressGeofence($contactAddressId, $radius = 25) {                                        if (empty($radius)) { $radius = 5; } $coordinates = $this->getAddressCoordinates($contactAddressId); return $this->getGeofence( $coordinates['latitude'], $coordinates['longitude'], (int) $radius ); } public function getZipCodeCoordinates($zipCode) {                        if (!empty($zipCode)) { $coordinates = $this->hMapService->getZipCodeCoordinates($zipCode); if ($coordinates !== false) { if (isset($coordinates['latitude']) && isset($coordinates['longitude'])) { $this->hLocationZipCodes->update( array( 'hLocationZipCodeLatitude' => (float) $coordinates['latitude'], 'hLocationZipCodeLongitude' => (float) $coordinates['longitude'] ), array( 'hLocationZipCode' => $zipCode ) ); $location = $this->hLocationZipCodes->selectAssociative( array( 'hLocationZipCodeLatitude', 'hLocationZipCodeLongitude' ), array( 'hLocationZipCode' => $zipCode ) ); return array( 'latitude' => (float) $location['hLocationZipCodeLatitude'], 'longitude' => (float) $location['hLocationZipCodeLongitude'] ); } else { $this->warning( "Map service '{$this->serviceName}' did not provide latitude and longitude ". "coordinates for zip code: '{$zipCode}'", __FILE__, __LINE__ ); } } else { $this->notice( "Map service '{$this->serviceName}' did not successfully query coordinates for ". "zip code: '{$zipCode}'", __FILE__, __LINE__ ); } } else { $this->notice( "Map service was not able to provide zip code coordinates because no zip code was ". "provided.", __FILE__, __LINE__ ); } return array(); } public function getZipCodeGeofence($zipCode, $radius = 25) {                                        if (empty($radius)) { $radius = 5; } $coordinates = $this->getZipCodeCoordinates($zipCode); return $this->getGeofence( $coordinates['latitude'], $coordinates['longitude'], (int) $radius ); } public function getCityCoordinates($city, $locationStateId, $locationCountryId = 223) {                         if (!empty($city) && !empty($locationStateId) && !empty($locationCountryId)) { $locationCityId = $this->hLocationCity->getId( $city, $locationStateId, $locationCountryId ); if (!empty($locationCityId) && $this->hMapCacheDisabled(false)) { $location = $this->hLocationCity->getLatitudeLongitude($locationCityId); return array( 'latitude' => $location['hLocationCityLatitude'], 'longitude' => $location['hLocationCityLongitude'] ); } $state = $this->hLocation->getStateName($locationStateId); $country = $this->hLocation->getCountryName( $locationCountryId, 'hLocationCountryISO3' ); $coordinates = $this->hMapService->getCityCoordinates("{$city}, {$state}, {$country}"); if ($coordinates !== false) { if (isset($coordinates['latitude']) && isset($coordinates['longitude'])) { if (!empty($locationCityId)) { $this->setCityCoordinates( $locationCityId, (float) $coordinates['latitude'], (float) $coordinates['longitude'] ); } else { $locationCityId = $this->createCityCoordinates( $city, $locationStateId, $locationCountryId, (float) $coordinates['latitude'], (float) $coordinates['longitude'] ); } if (!empty($locationCityId)) { $location = $this->hLocationCity->getLatitudeLongitude($locationCityId); return array( 'latitude' => $location['hLocationCityLatitude'], 'longitude' => $location['hLocationCityLongitude'] ); } } else { $this->warning( "Map service '{$this->serviceName}' did not provide latitude and longitude ". "coordinates for city, state: '{$city}, {$state}, {$country}'", __FILE__, __LINE__ ); } } else { $this->notice( "Map service '{$this->serviceName}' did not successfully query coordinates for ". "city, state: '{$city}, {$state}, {$country}'", __FILE__, __LINE__ ); } } else { $this->notice( "Map service was not able to provide city coordinates because a city, stateId, or ". "countryId was not provided.", __FILE__, __LINE__ ); } return array(); } public function getCityGeofence($city, $locationStateId, $locationCountryId = 223, $radius = 25) {                                         $coordinates = $this->getCityCoordinates( $city, $locationStateId, $locationCountryId ); return $this->getGeofence( $coordinates['latitude'], $coordinates['longitude'], $radius ); } public function createCityCoordinates($city, $locationStateId, $locationCountryId, $latitude, $longitude) {         return $this->hLocationCity->insert( array( 'hLocationCity' => $city, 'hLocationStateId' => (int) $locationStateId, 'hLocationCountryId' => (int) $locationCountryId, 'hLocationCityLatitude' => (float) $latitude, 'hLocationCityLongitude' => (float) $longitude ) ); } public function setCityCoordinates($locationCityId, $latitude, $longitude) {         $this->hLocationCity->setLatitudeLongitude( (int) $locationCityId, (float) $latitude, (float) $longitude ); } public function getGeofenceByLocation(array $options, $radius = 25) {              if (!empty($options['zipCode'])) { return $this->getZipCodeGeofence( $options['zipCode'], $radius ); } else if (!empty($options['city']) && !empty($options['stateId'])) { return $this->getCityGeofence( $options['city'], $options['stateId'], isset($options['countryId']) ? $options['countryId'] : 223, $radius ); } else if (!empty($options['byCoordinates'])) { return $this->getGeofence( $options['latitude'], $options['longitude'], $radius ); } return array(); } public function getGeofence(&$latitude, &$longitude, $radius) {            if (isset($latitude) && isset($longitude)) { return array( 'north' => $longitude - $radius / abs(cos(deg2rad($latitude)) * 69), 'south' => $longitude + $radius / abs(cos(deg2rad($latitude)) * 69), 'east' => $latitude - ($radius / 69), 'west' => $latitude + ($radius / 69), 'latitude' => (float) $latitude, 'longitude' => (float) $longitude, 'radius' => (int) $radius, 'proximity' => true ); } return array(); } public function useProximity(&$results) { return ( isset($results['north']) && isset($results['south']) && isset($results['east']) && isset($results['west']) ); } } ?>