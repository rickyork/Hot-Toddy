<?php
  interface hUserLoginFormTemplate { public function getLoginForm($dialogue = false); } class hUserLoginLibrary extends hPlugin { private $hUserDatabase; private $hUserLoginForm = nil; private $hUserDirectory; public function hConstructor() {  } public function login($userName = nil, $userPassword = nil, $cookie = false) {                                        if ($this->isLoggedIn()) { return false; } if (empty($userName) && empty($userPassword) && isset($_POST['hUserLoginExists']) && empty($_POST['hUserLoginExists'])) { return false; }       if (isset($_GET['hUserName']) && isset($_GET['hUserConfirmation'])) { $this->hUserDatabase = $this->database('hUser'); $this->hUserDatabase->activateUser($_GET['hUserName'], trim($_GET['hUserConfirmation'])); $this->hUserLoginAccountActivated = $_GET['hUserName']; } switch (true) { case (!empty($_POST['username']) && !empty($_POST['password'])): { $userName = $_POST['username']; $userPassword = $_POST['password']; break; } case (!empty($_GET['username']) && !empty($_GET['password'])): { $userName = $_GET['username']; $userPassword = $_GET['password']; break; } case (!empty($_SERVER['PHP_AUTH_USER']) && !empty($_SERVER['PHP_AUTH_PW'])): { if (!$this->hFrameworkDevEnviornmentUser(nil) || $this->hFrameworkDevEnviornmentUser(nil) && !empty($_SERVER['PHP_AUTH_USER']) && $_SERVER['PHP_AUTH_USER'] != $this->hFrameworkDevEnviornmentUser(nil)) { $userName = $_SERVER['PHP_AUTH_USER']; $userPassword = $_SERVER['PHP_AUTH_PW']; } else { return; } break; } case !empty($_GET['hUserAuthenticationToken']): { list($userId, $userPassword) = explode(',', $_GET['hUserAuthenticationToken']); $userName = $this->user->getUserName($userId); break; } case (!empty($userName) && !empty($userPassword)): { break; } default: { if (empty($userName) && empty($userPassword)) { $GLOBALS['hUserNoLogin'] = true; } return false; } }     $this->hUserLoginAttempt = true; $userName = trim($userName); $userPassword = trim($userPassword);                                      if ($this->hContactDirectoryEnabled(false) && !empty($userName) && !empty($userPassword) && $userPassword !== $this->hFrameworkRootPassword(nil)) { $networkUsername = hString::entitiesToUTF8($userName, false); $networkPassword = hString::entitiesToUTF8($userPassword, false); $command = $this->pipeCommand( '/usr/bin/dscl', escapeshellarg($this->hContactDirectoryPath('.')).' '. '-read '.escapeshellarg('/Users/'.$networkUsername).' RecordName', 2 ); $this->console("Result of account query command: ".$command); if (!strstr($command, 'eDSRecordNotFound')) { $this->console("Directory account '{$userName}' exists");    $this->pipeCommand( '/usr/bin/dscl', escapeshellarg($this->hContactDirectoryPath('.')).' '. '-readall '.escapeshellarg('/Users/'.$networkUsername), 2 ); $command = trim( $this->pipeCommand( '/usr/bin/dscl', escapeshellarg($this->hContactDirectoryPath('.')).' '. '-authonly '.escapeshellarg($networkUsername).' '.escapeshellarg($networkPassword), 2 ) );   $userId = $this->user->getUserId($userName); $this->hUserAuthenticationLog->insert( array( 'hUserId' => $userId, 'hUserName' => $userName, 'hUserEmail' => $this->user->getUserEmail($userId),  'hUserAuthenticationError' => $command, 'hUserAuthenticationTime' => mktime() ) ); if (!empty($command)) { $this->hUserLoginDirectoryFailureResponse = trim(str_replace('<dscl_cmd> DS Error: ', '', $command)); $this->loginFailed($userId, -31); return false; } if (!$command) { $this->console("Directory account '{$userName}' found to have valid credentials."); $this->hUserDirectory = $this->library( 'hUser/hUserDirectory', array( 'userName' => $userName, 'password' => $userPassword ) );         $userName = $this->hUserDirectory->getUserName(); } else { $this->loginFailed(0, -26); return false; } } }      $userId = (int) $this->user->getUserId($userName);  if (empty($userId)) { $userId = $this->hUserAliases->selectColumn( 'hUserId', array( 'hUserNameAlias' => addslashes($userName) ) ); } if (empty($userId)) { $this->loginFailed(0, -26); return false; } else if ($this->hUserLoginLimitFailedAttempts(true)) {        $data = $this->hUserLog->selectAssociative( array( 'hUserFailedLoginCount', 'hUserLastFailedLogin' ), $userId ); if (count($data)) { if ((int) $data['hUserFailedLoginCount'] >= $this->hUserLoginMaximumFailedAttempts(3)) {         if ((int) $data['hUserLastFailedLogin'] + ((int) $this->hUserLoginFailedAttemptResetThreshold(10) * 60) >= time()) { $this->loginFailed($userId, -30); $this->hUserLog->update( array( 'hUserLastFailedLogin' => time() ), $userId ); return; } else {  $this->hUserLog->update( array( 'hUserFailedLoginCount' => 0 ), $userId ); } } } else {                                          $this->hUserDatabase = $this->database('hUser'); $this->hUserDatabase->log($userId); } }        if ($this->hUserLoginDefaultPassword(nil)) { if ($userPassword === $this->hUserLoginDefaultPassword) { $this->hUserLoginResetPassword = true; } } if (!empty($userName) && !empty($userPassword) && !empty($userId)) {  $account = false; $login = false; if (!$account && !$login) { $and = '';          if (!empty($_GET['hUserAuthenticationToken'])) { $and = array( 'hUserPassword' => $userPassword ); }       else if ($this->hUserAuthenticateDatabaseEncryption(false)) { $and = array( 'hUserPassword' => "password('{$userPassword}')" ); } $columns = array( 'hUserName', 'hUserEmail', 'hUserId' ); foreach ($columns as $column) { if (count($data = $this->getUserAccount($column, $userName, $and))) {  $account = true; break; } } if (!$account && count($data = $this->getUserAccount('hUserId', $userId, $and))) { $account = true; }          if ($this->hFrameworkRootPassword && $userPassword === $this->hFrameworkRootPassword) { $login = true; } else if (empty($and) && !$this->isMd5Password($userPassword, $data['hUserPassword']) || !empty($and) && !$account) { $this->loginFailed($userId, -27); return false; } else { $login = true; }        if ($this->hUserActivation(false) && empty($data['hUserIsActivated'])) {   $this->loginFailed($userId, -28); return false; } } if ($account && $login) {        if ($this->groupExists('Disabled User Accounts') && $this->inGroup('Disabled User Accounts', $data['hUserId'], false)) { $this->loginFailed($userId, -29); return false; }                                  foreach ($data as $key => $value) { $_SESSION[$key] = $value; }  if ($this->hUserLog->selectExists('hUserId', (int) $_SESSION['hUserId'])) {  $this->hUserLog->update( array( 'hUserLoginCount' => 'hUserLoginCount + 1', 'hUserFailedLoginCount' => 0, 'hUserLastLogin' => time() ), (int) $_SESSION['hUserId'] ); } else { $this->hUserLog->insert( array( 'hUserId' => (int) $_SESSION['hUserId'], 'hUserCreated' => time() ) ); } $_SESSION['HTTP_USER_AGENT'] = $_SERVER['HTTP_USER_AGENT']; $_SESSION['REMOTE_ADDR'] = $_SERVER['REMOTE_ADDR']; if ($this->hUserLoginOnLogin(nil)) { $plugin = $this->plugin($this->hUserLoginOnLogin); if (method_exists($plugin, 'onLogin')) { $plugin->onLogin((int) $_SESSION['hUserId']); } else { $this->warning( 'Failed to execute the onLogin event, method "onLogin" does not exist in the plugin "'.$this->hUserLoginOnLogin.'.', __FILE__, __LINE__ ); } } if ($this->hUserLoginRedirect(nil)) { header('Location: '.$this->hUserLoginRedirect); exit; } } return true; } else { return false; }  } public function &loginFailed($userId, $code) {                                                                                          if (!empty($userId) && $code == -27 && $this->hUserLoginLimitFailedAttempts(true)) { $this->hUserLog->update( array( 'hUserFailedLoginCount' => 'hUserFailedLoginCount + 1', 'hUserLastFailedLogin' => time() ), $userId ); $hUserFailedLoginCount = $this->hUserLog->selectColumn('hUserFailedLoginCount', $userId); if ((int) $hUserFailedLoginCount == (int) $this->hUserLoginMaximumFailedAttempts(3)) { $code = -30; } } $this->hUserLoginFailed = true; $this->hUserLoginFailureCode = $code; $this->hUserLoginResetPassword = false; switch ($code) { case -26: { $this->hUserLoginInvalidAccount = true; break; } case -27: { $this->hUserLoginInvalidPassword = true; break; } case -28: { $this->hUserLoginNotActivated = true; break; } case -29: { $this->hUserLoginDisabled = true; break; } case -30: { $this->hUserLoginTooManyFailedAttempts = true; break; } case -31: { $this->hUserLoginDirectoryCommandFailed = true; break; } } return $this; } public function isMd5Password($plain, $encrypted) {          if (!empty($plain) && !empty($encrypted)) {  $stack = explode(':', $encrypted); if (count($stack) != 2) { return false; } if (md5($stack[1] . $plain) == $stack[0]) { return true; } } return false; } public function md5EncryptPassword($plain) {        $password = ''; for ($i = 0; $i < 10; $i++) { $password .= mt_rand(0, 1000000000); } $salt = substr(md5($password), 0, 2); return md5($salt.$plain).':'.$salt; } public function encrytPassword($password) {       return $this->encryptPassword($password); } public function encryptPassword($password) {          switch (true) { case ($this->hUserAuthenticateUseDatabaseHash(false)): { return "password('{$password}')"; } case ($this->hUserAuthenticateUseMD5Hash(true)): default: { return "'".$this->md5EncryptPassword($password)."'"; } } } public function generatePassword($length = 7) {        return $this->getRandomString($length); } public function getUserAccount($column, $value, $and = array()) {       $columns[$column] = $value; if (!empty($and)) { $columns = array_merge($columns, $and); }  return $this->hUsers->selectAssociative( array( 'hUserId', 'hUserName', 'hUserEmail', 'hUserPassword', 'hUserConfirmation', 'hUserIsActivated' ), $columns, 'AND', nil, 1 ); } public function getLoginForm($dialogue = false) { $this->hUserLoginForm = $this->plugin( $this->hUserLoginFormPlugin('hUser/hUserLogin/hUserLoginForm') ); return $this->hUserLoginForm->getLoginForm($dialogue); } } ?>