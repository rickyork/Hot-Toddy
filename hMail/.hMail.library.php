<?php
  class hMailLibrary extends hPlugin { private $preview = false; private $message = array(); private $saveToDisk = false; private $email = array(); private $text; private $html; private $debug = false; private $queue = false; private $sendMethod; private $debugSendmail; private $sendmailPath; private $returnPath; private $templateName = null; private $options = array(); private $json; private $hMailMIME; private $hMailDatabase; public function hConstructor() {                   $this->hMailMIME = $this->library('hMail/hMailMIME'); $this->hMailMIME->setMailer(', Hot Toddy <http://www.hframework.com/>'); if ($this->hMailQueue(false)) { $this->queue = $this->hMailQueue(false); } $this->hMailDatabase = $this->database('hMail'); }      public function &setTo($address, $name = null, $contactId = 0) {       $this->addAddressHeader( 'To', $address, $name, $contactId ); return $this; } public function &addTo($address, $name = null, $contactId = 0) {       return $this->setTo( $address, $name, $contactId ); } public function &setCc($address, $name = null, $contactId = 0) {       $this->addAddressHeader( 'Cc', $address, $name, $contactId ); return $this; } public function &addCc($address, $name = null, $contactId = 0) {       return $this->setCc( $address, $name, $contactId ); } public function &setBcc($address, $name = null, $contactId = 0) {       $this->addAddressHeader( 'Bcc', $address, $name, $contactId ); return $this; } public function &addBcc($address, $name = null, $contactId = 0) {       return $this->addBcc( $address, $name, $contactId ); } public function &setFrom($address, $name = null, $contactId = 0) {       $this->addAddressHeader( 'From', $address, $name, $contactId ); return $this; } public function &setReplyTo($address, $name = null, $contactId = 0) {       $this->addAddressHeader( 'Reply-To', $address, $name, $contactId ); return $this; } public function &setReturnPath($address, $name = null, $contactId = 0) {       $this->addAddressHeader( 'Return-Path', $address, $name, $contactId ); return $this; } public function &setSubject($subject) {       $this->message['Subject'] = $subject; return $this; } public function &setText($text) {       $this->text = $text; return $this; } public function &setHTML($html) {       $this->html = $html; return $this; } private function cleanInput(&$value, $isAddress = true) {          if (!$isAddress) { $value = str_replace('@', '', $value); } else if (substr_count($value, '@') > 1) { $value = ''; }     $value = str_replace( array(':', ',', '<', '>', "\n", "\r"), '', hString::decodeEntitiesAndUTF8($value) ); } private function addAddressHeader($header, $address, $name = '', $id = 0) {                                       $this->cleanInput($address); $this->cleanInput($name, false); $address = strToLower($address); if (!empty($address)) { if (!isset($this->message[$header])) { $this->message[$header] = array( 'address' => array(), 'account' => array(), 'domain' => array(), 'name' => array(), 'id' => array() ); } $addressCount = count($this->message[$header]['address']); if (!$this->isRecipient($header, $address)) { $this->message[$header]['address'][$addressCount] = $address; list($account, $domain) = explode('@', $address); $this->message[$header]['account'][$addressCount] = $account; $this->message[$header]['domain'][$addressCount] = $domain; $this->message[$header]['name'][$addressCount] = $name; $this->message[$header]['id'][$addressCount] = $id; } } } public function isRecipient($header, $address) {          if ($header == 'To' || $header == 'Cc' || $header == 'Bcc') { return( isset($this->message['To']['address']) && is_array($this->message['To']['address']) && in_array($address, $this->message['To']['address']) || isset($this->message['Cc']['address']) && is_array($this->message['Cc']['address']) && in_array($address, $this->message['Cc']['address']) || isset($this->message['Bcc']['address']) && is_array($this->message['Bcc']['address']) && in_array($address, $this->message['Bcc']['address']) ); } return false; } public function explodeAddressList($header, $addressList) {          $addresses = explode(',', $addressList); foreach ($addresses as $address) {   if (strstr($address, '<')) {  $matches = array(); preg_match('/^(.*)<(.*)>$/U', trim($address), $matches); if (!empty($matches[2]) && strstr($matches[2], '@')) { $this->{"set{$header}"}(isset($matches[2])? trim($matches[2]) : '', isset($matches[1])? trim($matches[1]): ''); } } else if (strstr($address, '@')) { $this->{"set{$header}"}(trim($address)); } } } public function implodeAddressList($header) {                $addresses = array(); foreach ($this->message[$header]['address'] as $i => $address) { $addresses[] = !empty($this->message[$header]['name'][$i])? $this->message[$header]['name'][$i].' <'.$address.'>' : $address; } return implode(',', $addresses); } public function sendMail($templateName, $templateVariables, $callingPluginPath, $json, $jsonmtime) { $this->json = $json;                                                                                                                                                                                   $pluginPath = dirname($callingPluginPath); $this->option('debug', 'hMailDebug') ->option('preview', 'hMailPreview') ->option('queue', 'hMailQueue') ->option('saveToDisk', 'hMailSaveToDisk') ->option('sendMethod', 'hMailSendMethod') ->option('debugSendmail', 'hMailDebugSendmail') ->option('sendmailPath', 'hMailSendmailPath') ->option('returnPath', 'hMailReturnPath');                                                         $this- >mimeOption( 'smtpServer', 'hMailSMTPServer', 'setSMTPServer' ) ->mimeOption( 'smtpHelo', 'hMailSMTPHelo', 'setSMTPHelo' ) ->mimeOption( 'smtpAuthMethod', 'hMailSMTPAuthMethod', 'setSMTPAuthMethod' ); $this->hMailDatabase->saveTemplateFromJSON( $templateName, $this->json, $jsonmtime ); $baseTemplatePath = $this->getIncludePath( $this->hServerDocumentRoot.dirname($callingPluginPath) ); $htmlPath = ''; $textPath = ''; if (!isset($templateVariables['hMailHTMLTemplate']) || empty($templateVariables['hMailHTMLTemplate'])) { switch (true) { case isset($this->json->hMailHTML): { $htmlPath = $this->json->hMailHTML; break; } case isset($this->json->html): { $htmlPath = $this->json->html; break; } case isest($this->json->HTML): { $htmlPath = $this->json->HTML; break; } default: { $htmlPath = $templateName; } } $htmlPath = "{$baseTemplatePath}/HTML/{$htmlPath}.html"; switch (true) { case isset($this->json->hMailText): { $textPath = $this->json->hMailText; break; } case isset($this->json->text): { $textPath = $this->json->text; break; } default: { $textPath = $templateName; } } $textPath = "{$baseTemplatePath}/TXT/{$textPath}.txt"; } if (!empty($htmlPath) && !file_exists($htmlPath)) { $htmlPath = ''; $this->notice( "The HTML path '{$htmlPath}' does not exist. Regarding mail template: '{$templateName}'.", __FILE__, __LINE__ ); } if (!empty($textPath) && !file_exists($textPath)) { $textPath = ''; $this->notice( "The path to plain text file '{$textPath}' does not exist. Regarding mail template: '{$templateName}'.", __FILE__, __LINE__ ); } $this->getMessageFromTemplate( $templateName, $templateVariables, $htmlPath, $textPath ); } private function &mimeOption($option, $name, $method) { if (isset($this->json->$name)) { $this->hMailMIME->$method($this->json->$name); unset($this->json->$name); } if (isset($this->json->$option)) { $this->hMailMIME->$method($this->json->$option); unset($this->json->$option); } return $this; } private function &option($option, $name) { if (isset($this->json->$name)) { $this->$option = $this->json->$name; unset($this->json->$name); } if (isset($this->json->$option)) { $this->$option = $this->json->$option; unset($this->json->$option); } return $this; } public function getMessageFromTemplate($mailTemplateId, $variables = array(), $htmlPath = null, $textPath = null) {                      $this->templateName = $this->hMailDatabase->getTemplateName($mailTemplateId); $message = $this->hMailDatabase->getTemplate($mailTemplateId); if (count($message)) { $expandHTMLAndText = true; if (!empty($htmlPath)) { $message['hMailHTML'] = $this->getTemplate( $htmlPath, $variables ); $expandHTMLAndText = false; } else if (!empty($variables['hMailHTMLTemplate'])) { $message['hMailHTML'] = $this->parseTemplateMarkup( $variables['hMailHTMLTemplate'], $variables ); $expandHTMLAndText = false; } else if (!empty($this->html)) { $message['hMailHTML'] = $this->parseTemplateMarkup( $this->html, $variables ); } else { $message['hMailHTML'] = ''; } if (!empty($textPath)) { $message['hMailText'] = $this->getTemplate( $textPath, $variables ); $expandHTMLAndText = false; } else if (!empty($variables['hMailTextTemplate'])) { $message['hMailText'] = $this->parseTemplateMarkup( $variables['hMailTextTemplate'], $variables ); $expandHTMLAndText = false; } else if (!empty($this->text)) { $message['hMailText'] = $this->parseTemplateMarkup( $this->text, $variables ); } else { $message['hMailText'] = ''; } foreach ($message as $key => &$value) { $header = preg_replace('/hMail/', '', $key); if ((!$expandHTMLAndText && $key != 'hMailHTML' && $key != 'hMailText') || $expandHTMLAndText) { $value = hString::decodeHTML($value); $value = $this->parseTemplateMarkup( $value, $variables ); } switch ($key) { case 'hMailTo': case 'hMailCc': case 'hMailBcc': case 'hMailFrom': case 'hMailReplyTo': { $this->explodeAddressList($header, $value); break; } default: { $this->{"set{$header}"}($value); break; } } } } else { $this->warning( "Mailer template: '{$mailTemplateId}' does not exist.", __FILE__, __LINE__ ); } if ($this->preview) { if (!$this->saveToDisk) { $this->hTemplatePath = ''; $this->hFileCSS = ''; $this->hFileJavaScript = ''; $this->hFileDocument = $this->html; return; } else { $mailerPath = $this->hFrameworkTemporaryPath.'/'.$this->templateName.'.html'; if (file_exists($mailerPath)) { $this->rm($mailerPath, true); } file_put_contents( $mailerPath, $this->html ); return; } } else { $this->send(); } $this->reset(); } public function previewMessage() {                    $this->preview = true; } public function debugMessage() {               $this->debug = true; } public function queueMessages() {                  $this->queue = true; } public function send($rtn = false) {            if (empty($this->sendMethod)) { $this->sendMethod = $this->hMailSendMethod('sendmail'); } $recipients = array(); if ($this->addressesExist('To') || $this->addressesExist('Cc') || $this->addressesExist('Bcc')) { $this->hMailMIME ->setTextCharset('UTF-8') ->setHTMLCharset('UTF-8') ->setHeadCharset('UTF-8'); foreach ($this->message as $header => $value) { if ($header == 'To' && $this->sendMethod == 'smtp' && !$this->debug) { $recipients = $value['address']; } else { $value = is_array($this->message[$header])? $this->implodeAddressList($header) : $this->message[$header]; $this->hMailMIME->setHeader($header, $value); } } if (!empty($this->text)) { $this->hMailMIME->setText($this->text); } if (!empty($this->html)) { $this->hMailMIME->setHTML($this->html, $this->hFileSystemPath); } if ($this->debugSendmail === null) { $this->debugSendmail = $this->hMailDebugSendmail(false); } if (empty($this->sendmailPath)) { $postfixConfiguration = $this->hMailPostfixConfigurationPath(null); if (!empty($postfixConfiguration)) { $postfixConfiguration = '-C '.$postfixConfiguration; } $this->sendmailPath = $this->hMailSendmailPath('/usr/sbin/sendmail '.$postfixConfiguration.' -ti -r'); } if (empty($this->returnPath)) { $this->returnPath = $this->hMailReturnPath; } $this->hMailMIME->setReturnPath($this->returnPath); if ($this->debug && !$this->queue) { if (!$this->saveToDisk) { $this->setDocumentForDebug(hString::encodeHTML($this->hMailMIME->getRFC822())); return; } else { $mailerPath = $this->hFrameworkTemporaryPath.'/'.$this->templateName.'.eml'; if (file_exists($mailerPath)) { $this->rm($mailerPath, true); } file_put_contents( $mailerPath, $this->hMailMIME->getRFC822() ); } } else if ($rtn) { return $this->hMailMIME->getRFC822(); } else if ($this->queue) { $mailMime = hString::encodeHTML($this->hMailMIME->freeze()); $mailLibrary = hString::encodeHTML($this->freeze()); if ($this->debug) { $this->setDocumentForDebug( "hMailMIME:\n". $mailMime."\n\n". "hMailLibrary:\n". $mailLibrary."\n\n" ); } else {  $this->hDatabase->insert( array( 'hMailQueueId' => null, 'hMailMIME' => $mailMime, 'hMailLibrary' => $mailLibrary ), 'hMailQueue' ); } } else { switch ($this->sendMethod) { case 'smtp': { $this->hMailMIME->send($recipients, 'smtp'); break; } case 'mail': { $this->hMailMIME->send($recipients, 'mail'); break; } case 'sendmail': {  $folder = $this->hFrameworkTemporaryPath.'/Sendmail.txt'; $resources = array( 0 => array('pipe', 'r'),  1 => array('pipe', 'w'),  2 => array('file', $folder, 'a')  ); $pipes = array(); $sendmailEnv = array(); if ($this->debugSendmail) { $sendmailEnv = array( 'MAIL_VERBOSE' => 1, 'MAIL_DEBUG' => 1 ); } $process = proc_open( $this->sendmailPath.' '.$this->returnPath, $resources, $pipes, '/tmp', $sendmailEnv ); if (is_resource($process)) {     fwrite($pipes[0], trim($this->hMailMIME->getRFC822())); fclose($pipes[0]); $this->console("Mail: ".stream_get_contents($pipes[1])); fclose($pipes[1]);   $return = proc_close($process); $this->console("Sendmail command returned {$return}"); } break; } default: { $this->warning( 'Invalid value for hMailSendMethod, '.$this->hMailSendMethod('sendmail'), __FILE__, __LINE__ ); } } } $this->reset(); if (isset($bytes)) { return $bytes; } } else { $this->warning( 'There are no addresses specified to send the message to.', __FILE__, __LINE__ ); } return 0; } private function setDocumentForDebug($document) {          $this->hFileCSS = ''; $this->hFileJavaScript = ''; $this->plugin('hApplication/hApplicationForm'); $this->hFileTitle = "Debug Mailer"; $this->hFileDocument = "<pre>{$document}</pre>\n"; } public function reset() {          $this->preview = false; $this->message = array(); $this->email = array(); $this->text = null; $this->html = null; $this->debug = false; $this->queue = false; $this->hMailMIME->hConstructor(); } private function addressesExist($header) {           return isset($this->message[$header]) && count($this->message[$header]['address']); } private function correctEncoding(&$array) {        foreach ($array as $key => $value) { switch ($key) { case 'html': case 'text': { break; } default: { $array[$key] = hString::decodeEntitiesAndUTF8($value); } } } } private function freeze() {          $data = array( 'preview' => $this->preview, 'message' => $this->message, 'saveToDisk' => $this->saveToDisk, 'email' => $this->email, 'text' => $this->text, 'html' => $this->html, 'debug' => $this->debug, 'queue' => $this->queue, 'sendMethod' => $this->sendMethod, 'debugSendmail' => $this->debugSendmail, 'sendmailPath' => $this->sendmailPath, 'returnPath' => $this->returnPath, 'templateName' => $this->templateName ); return serialize($data); } private function restore($data) {         $data = unserialize($data); $this->preview = false; $this->message = $data['message']; $this->saveToDisk = false; $this->email = $data['email']; $this->text = $data['text']; $this->html = $data['html']; $this->debug = false; $this->queue = false; $this->sendMethod = $data['sendMethod']; $this->debugSendmail = $data['debugSendmail']; $this->sendmailPath = $data['sendmailPath']; $this->returnPath = $data['returnPath']; $this->templateName = $data['templateName']; } public function emptyQueue() {          $query = $this->hMailQueue->select( array( 'hMailQueueId', 'hMailMIME', 'hMailLibrary' ) ); $i = 0; foreach ($query as $data) { $mailMime = hString::decodeEntitiesAndUTF8($data['hMailMIME']); $mailLibrary = hString::decodeEntitiesAndUTF8($data['hMailLibrary']); $this->hMailMIME->restore($mailMime); $this->restore($mailLibrary); $this->send(); $this->console("Message Sent hMailQueueId:{$data['hMailQueueId']}"); $this->hMailQueue->delete('hMailQueueId', $data['hMailQueueId']); $i++; } $this->console("\nNumber of messages sent: {$i}\n"); } } ?>